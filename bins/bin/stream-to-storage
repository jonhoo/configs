#!/bin/bash

set -euo pipefail

cor=0
if [[ $1 = "--crust-of-rust" ]]; then
	cor=1
	shift
fi
wpr=
if [[ $1 = "--with-postroll" ]]; then
	wpr="$2"
	shift
	shift
fi
wmr=
pre=
if [[ $1 = "--with-midroll" ]]; then
	# when --with-midroll is passed, the first positional argument is the video _before_ the midroll.
	wmr="$2"
	shift
	shift
	pre="$1"
	if [[ "$(dirname "$pre")" = "." ]]; then
		# ffmpeg doesn't like : in filenames without leading ./
		input="./$pre"
	fi
	shift
	case "$#" in
		"0")
			echo "Midroll requires <pre-ad> + <post-ad>"
			exit 1
			;;
		"1")
			;;
		*)
			echo "Midroll does not support many files"
			exit 1
			;;
	esac
fi

for file in "$@"; do
	echo "==> $file"
	input="$file"
	filename="$(basename "$file")"
	if [[ "$(dirname "$input")" = "." ]]; then
		# ffmpeg doesn't like : in filenames without leading ./
		input="./$filename"
	fi
	base="${filename%.mkv}"
	date=$(echo "$base" | perl -npe 's/^([0-9-]{10})[ T]([0-9]{2})[-:]([0-9]{2})[-:]([0-9]{2})(Z)?.*/\1T\2:\3:\4\5/')
	year=$(date +%Y -d "$date")
	case "$year" in
		2018|2019)
			tz="America/New_York"
			;;
		2020)
			month=$(date +%m -d "$date")
			case "$month" in
				10|11|12)
					tz="America/Los_Angeles"
					;;
				*)
					tz="America/New_York"
					;;
			esac
			;;
		2021|2022)
			tz="America/Los_Angeles"
			;;
		2023)
			month=$(date +%m -d "$date")
			case "$month" in
				01|02|03|04|05)
					tz="America/Los_Angeles"
					;;
				*)
					tz="Europe/Oslo"
					;;
			esac
			;;
		*)
			tz="Europe/Oslo"
			;;
	esac
	date_in_tz=$(TZ="$tz" date --iso-8601=seconds -d "$date")
	date=$(date --iso-8601=seconds -u -d "$date_in_tz")
	date=$(echo "$date" | sed 's/+00:00$/Z/')

	# copy="$base.original.mkv"
	# echo " -> hardlinking to ./$copy"
	# ln "$file" "$copy"

	# corrected="$base.corrected.mkv"
	# echo " -> correcting audio via $corrected"
	# ffmpeg -i "$input" \
	#      -itsoffset 0.200 -i "$input" \
	#      -map 0:0 -map 1:1 \
	#      -acodec copy \
	#      -vcodec copy \
	#       "$corrected"
	# input=$corrected

	# if true; then
	# 	short="$date.short.mkv"
	# 	ffmpeg -i "$file" -t 30 -c:a copy -c:v copy "file:$short"
	# 	input=./$short
	# fi

	final="$date.final.mkv"
	if [[ -e "$final" ]]; then
		echo " !! refusing to overwrite $final"
		echo " -> evaluating VMAF"
		ab-av1 vmaf --reference "$file" --distorted "./$final" --vmaf n_threads=24 --vmaf n_subsample=8
		bsize=$(numfmt --to=iec-i --suffix=B --format="%.1f" "$(stat -c '%s' "$final")")
		echo " -> $asize to $bsize"
		continue
	fi

	reencoded="$date.reencoded.mkv"
	# first, re-encode the video (and add the intro if necessary)
	# that we encode the audio to flac to avoid loss before normalization
	asize=$(numfmt --to=iec-i --suffix=B --format="%.1f" "$(stat -c '%s' "$file")")
	# one day: -e='.. -pix_fmt yuv420p10le'
	enc=(-c:a flac -c:v libsvtav1 -preset 6 -crf 23 -g 250 -pix_fmt yuv420p)
	if [[ $cor -eq 1 ]]; then
		echo " -> reencoding $asize video with CoR intro to $reencoded"
		inw=$(ffprobe -v error -select_streams v:0 -show_entries stream=width -of default=noprint_wrappers=1:nokey=1 "$input")
		inh=$(ffprobe -v error -select_streams v:0 -show_entries stream=height -of default=noprint_wrappers=1:nokey=1 "$input")
		inr=$(ffprobe -v error -select_streams v:0 -show_entries stream=r_frame_rate -of default=noprint_wrappers=1:nokey=1 "$input")
		echo "$inw x $inh @ $inr"
		time ffmpeg \
			-v quiet -loglevel quiet -stats \
			-i ~/media/crust-of-rust-intro.mp4 \
			-i "$input" \
			-filter_complex "[0:v]scale=$inw:$inh:force_original_aspect_ratio=1[v0]; [v0][0:a:0] [1:v:0][1:a:0] concat=n=2:v=1:a=1 [v] [a]" \
			-map '[v]' -map '[a]' \
			-r "$inr" \
			"${enc[@]}" \
			"./$reencoded"
	elif [[ -n "$wpr" ]]; then
		echo " -> reencoding $asize video with post-roll to $reencoded"
		ind=$(ffprobe -v error -select_streams v:0 -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$input")
		trim=$(echo "$ind - 0.5" | bc -l)
		offset=$(echo "$trim - 1" | bc -l)
		time ffmpeg \
			-to "$trim" \
			-i "$input" \
			-i "$wpr" \
			-filter_complex "[0:v]settb=AVTB,format=yuv420p[v0]; \
		                         [1:v]settb=AVTB,format=yuv420p[v1]; \
		                         [v0][v1]xfade=transition=pixelize:duration=0.3:offset=$offset,format=yuv420p[v]; \
		                         [0:a]atrim=0:$offset,asetpts=PTS-STARTPTS[a0]; \
		                         [1:a]atrim=start=0,asetpts=PTS-STARTPTS[a1]; \
		                         [a0][a1]concat=n=2:v=0:a=1[a]" \
			-map "[v]" -map "[a]" \
			"${enc[@]}" \
			"./$reencoded"
	elif [[ -n "$wmr" ]]; then
		echo " -> reencoding $asize video with mid-roll to $reencoded"
		pred=$(ffprobe -v error -select_streams v:0 -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$pre")
		add=$(ffprobe -v error -select_streams v:0 -show_entries format=duration -of default=noprint_wrappers=1:nokey=1 "$wmr")
		fadedur=0.3
		# First transition: pre -> midroll at (pred - 1)
		incoming=$(echo "$pred - 1" | bc -l)
		# Second transition: midroll -> post
		# Must account for the 0.3s overlap from first xfade
		# Combined stream [v01] has length: pred + add - fadedur
		# We want transition 1s before end, so: pred + add - fadedur - 1
		outgoing=$(echo "$pred + $add - $fadedur - 1" | bc -l)
		# Audio cuts at the start of each video crossfade for better sync
		audio_trim=$(echo "$incoming" | bc -l)
		midroll_trim=$(echo "$add - $fadedur" | bc -l)
		time ffmpeg \
			-i "$pre" \
			-i "$wmr" \
			-i "$input" \
			-filter_complex "[0:v]settb=AVTB,format=yuv420p[v0]; \
		                         [1:v]settb=AVTB,format=yuv420p[v1]; \
		                         [2:v]settb=AVTB,format=yuv420p[v2]; \
		                         [v0][v1]xfade=transition=pixelize:duration=$fadedur:offset=$incoming,format=yuv420p[v01]; \
		                         [v01][v2]xfade=transition=pixelize:duration=$fadedur:offset=$outgoing,format=yuv420p[v]; \
		                         [0:a]atrim=0:$audio_trim,asetpts=PTS-STARTPTS[a0]; \
		                         [1:a]atrim=0:$midroll_trim,asetpts=PTS-STARTPTS[a1]; \
		                         [2:a]asetpts=PTS-STARTPTS[a2]; \
		                         [a0][a1][a2]concat=n=3:v=0:a=1[a]" \
			-map "[v]" -map "[a]" \
			"${enc[@]}" \
			"./$reencoded"
	else
		echo " -> reencoding $asize video to $reencoded"
		time ffmpeg \
			-v quiet -loglevel quiet -stats \
			-i "$input" \
			"${enc[@]}" \
			"./$reencoded"
	fi

	# then, we normalize the audio while copying the video
	# we do this in a separate step since ffmpeg-normalize can't concat
	bsize=$(numfmt --to=iec-i --suffix=B --format="%.1f" "$(stat -c '%s' "$reencoded")")
	echo " -> normalizing reencoded $bsize video to $final"
	time ffmpeg-normalize "./$reencoded" \
		--keep-loudness-range-target -t -14 \
		--dual-mono \
		-c:a libopus -b:a 192k \
		-c:v copy \
		-o "./$final" \
		--progress
	csize=$(numfmt --to=iec-i --suffix=B --format="%.1f" "$(stat -c '%s' "$final")")
	echo " == reencoding done ($csize)"

	rm "./$reencoded"
done
